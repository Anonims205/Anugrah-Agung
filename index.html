<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GOJO SATORU - HOLLOW PURPLE: SELF CAPTURE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&family=Roboto+Mono:wght@300&display=swap');
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000;
        }
        
        /* Video background dengan efek minimal */
        #webcam { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
            transform: scaleX(-1); 
            opacity: 0.9; /* Ditingkatkan dari 0.4 ke 0.9 */
            z-index: 0; 
            filter: grayscale(20%) contrast(110%) brightness(100%); /* Lebih natural */
        }
        
        /* Canvas untuk efek 3D */
        canvas { 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
            transform: scaleX(-1); 
        }
        
        /* Loading screen */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            z-index: 20;
            text-shadow: 0 0 20px #A020F0, 0 0 40px #0000FF;
            animation: pulse 2s infinite;
            background: rgba(0,0,0,0.7);
            padding: 20px 40px;
            border-radius: 60px;
            backdrop-filter: blur(10px);
            border: 2px solid #A020F0;
            white-space: nowrap;
        }
        
        /* Status indicator dengan transparansi */
        #status {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: white;
            font-family: 'Roboto Mono', monospace;
            font-size: 16px;
            z-index: 15;
            background: rgba(0,0,0,0.6);
            padding: 15px 25px;
            border-radius: 40px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(160, 32, 240, 0.5);
            letter-spacing: 1px;
            box-shadow: 0 0 20px rgba(160,32,240,0.3);
        }
        
        #status span {
            color: #A020F0;
            font-weight: bold;
            text-shadow: 0 0 15px #A020F0;
            animation: blink 1.5s infinite;
        }
        
        /* Title di kanan atas */
        .glow-text {
            position: absolute;
            top: 30px;
            right: 30px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            z-index: 15;
            text-align: right;
            background: linear-gradient(90deg, transparent, rgba(0,0,0,0.8));
            padding: 20px 35px;
            border-radius: 0 0 0 30px;
            border-left: 4px solid #A020F0;
            border-bottom: 2px solid #A020F0;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 30px rgba(160,32,240,0.3);
        }
        
        .glow-text h1 {
            margin: 0;
            font-size: 42px;
            color: #fff;
            text-shadow: 0 0 20px #A020F0, 0 0 40px #0000FF;
            letter-spacing: 6px;
            line-height: 1.2;
        }
        
        .glow-text p {
            margin: 5px 0 0;
            opacity: 0.9;
            font-size: 14px;
            color: #fff;
            text-shadow: 0 0 10px #A020F0;
        }
        
        /* Webcam quality indicator */
        #cam-quality {
            position: absolute;
            top: 30px;
            left: 30px;
            color: #0f0;
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            z-index: 15;
            background: rgba(0,0,0,0.4);
            padding: 8px 15px;
            border-radius: 20px;
            backdrop-filter: blur(4px);
            border: 1px solid #0f0;
            box-shadow: 0 0 15px rgba(0,255,0,0.3);
            pointer-events: none;
        }
        
        .green-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            background: #0f0;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse-green 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; text-shadow: 0 0 20px #A020F0, 0 0 40px #0000FF; }
            50% { opacity: 0.7; text-shadow: 0 0 40px #FF0000, 0 0 80px #A020F0; }
            100% { opacity: 1; text-shadow: 0 0 20px #A020F0, 0 0 40px #0000FF; }
        }
        
        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(0,255,0,0.7); }
            70% { box-shadow: 0 0 0 10px rgba(0,255,0,0); }
            100% { box-shadow: 0 0 0 0 rgba(0,255,0,0); }
        }
        
        /* Kontrol untuk kamera */
        .cam-control {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 15;
            display: flex;
            gap: 10px;
        }
        
        .cam-btn {
            background: rgba(0,0,0,0.6);
            color: white;
            border: 1px solid #A020F0;
            padding: 12px 20px;
            border-radius: 40px;
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(8px);
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(160,32,240,0.3);
        }
        
        .cam-btn:hover {
            background: #A020F0;
            border-color: white;
            transform: scale(1.05);
            box-shadow: 0 0 30px #A020F0;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .glow-text h1 { font-size: 28px; }
            .glow-text { padding: 15px 20px; }
            #status { font-size: 12px; padding: 10px 15px; }
        }
    </style>
</head>
<body>

    <div id="loading">üîÆ ACTIVATING SELF CAPTURE MODE üîÆ</div>
    
    <div class="glow-text">
        <h1>HOLLOW PURPLE</h1>
        <p>‚àû IMAGINARY TECHNIQUE: VOID ‚àû</p>
    </div>
    
    <div id="cam-quality">
        <span class="green-dot"></span> CAMERA ACTIVE ¬∑ READY
    </div>
    
    <div id="status">
        <span>‚óâ</span> BRING TWO INDEX FINGERS TOGETHER
    </div>
    
    <div class="cam-control">
        <button class="cam-btn" onclick="toggleCamera()">üì∑ TOGGLE CAMERA</button>
    </div>
    
    <video id="webcam" playsinline autoplay muted></video>
    <canvas id="output_canvas"></canvas>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0';

        // --- KONFIGURASI ---
        const CONFIG = {
            redColor: 0xFF3366,
            blueColor: 0x3366FF,
            purpleColor: 0xAA44FF,
            mergeDistance: 0.2,
            particleCount: 1500,
            explosionParticles: 4000
        };

        // --- STATE ---
        let handLandmarker = null;
        let webcamRunning = false;
        let lastVideoTime = -1;
        let redSphere, blueSphere, purpleExplosion, domainRing;
        let isExploding = false;
        let domainActive = false;
        let cameraEnabled = true;
        
        // Setup Scene
        const scene = new THREE.Scene();
        scene.background = null; // Transparan agar video terlihat
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 2.5;
        
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('output_canvas'), 
            alpha: true, // Alpha true untuk transparansi
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000, 0); // Transparan

        // Post Processing
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.3, 0.7);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.2;
        
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- TEXTURE ---
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.3, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.6, 'rgba(160,32,240,0.4)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        const particleTexture = createParticleTexture();

        // --- BACKGROUND STARS (Reduced opacity) ---
        function createBackgroundStars() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            for (let i = 0; i < 500; i++) { // Kurangi jumlah stars
                const r = 3 + Math.random() * 8;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0x88AAFF,
                size: 0.02,
                transparent: true,
                opacity: 0.15, // Lebih transparan
                blending: THREE.AdditiveBlending
            });
            
            return new THREE.Points(geometry, material);
        }

        const stars = createBackgroundStars();
        scene.add(stars);

        // --- ENERGY SPHERE ---
        function createEnergySphere(color, isRed = true) {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const radius = 0.22;
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const r = radius * Math.pow(Math.random(), 1.3);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: color,
                size: 0.04,
                map: particleTexture,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const sphere = new THREE.Points(geometry, material);
            sphere.visible = false;
            return sphere;
        }

        // --- HOLLOW PURPLE EXPLOSION ---
        function createHollowPurple() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            const colors = [];
            
            for (let i = 0; i < CONFIG.explosionParticles; i++) {
                positions.push(0, 0, 0);
                
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const speed = 0.02 + Math.random() * 0.12;
                
                velocities.push(
                    speed * Math.sin(phi) * Math.cos(theta),
                    speed * Math.sin(phi) * Math.sin(theta),
                    speed * Math.cos(phi)
                );
                
                // Warna gradien
                const mix = Math.random();
                let r, g, b;
                if (mix < 0.4) {
                    r = 1.0; g = 0.2; b = 0.3;
                } else if (mix < 0.8) {
                    r = 0.3; g = 0.4; b = 1.0;
                } else {
                    r = 0.8; g = 0.3; b = 1.0;
                }
                
                colors.push(r, g, b);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.06,
                map: particleTexture,
                vertexColors: true,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const system = new THREE.Points(geometry, material);
            system.userData = { 
                active: false, 
                time: 0,
                velocities: velocities
            };
            return system;
        }

        // --- DOMAIN RING ---
        function createDomainRing() {
            const geometry = new THREE.TorusGeometry(0.6, 0.02, 32, 100);
            const material = new THREE.MeshBasicMaterial({
                color: 0xAA44FF,
                transparent: true,
                opacity: 0.2,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(geometry, material);
            ring.rotation.x = Math.PI / 2;
            ring.position.z = -0.3;
            return ring;
        }

        // Initialize objects
        redSphere = createEnergySphere(CONFIG.redColor, true);
        blueSphere = createEnergySphere(CONFIG.blueColor, false);
        purpleExplosion = createHollowPurple();
        domainRing = createDomainRing();
        
        scene.add(redSphere);
        scene.add(blueSphere);
        scene.add(purpleExplosion);
        scene.add(domainRing);
        domainRing.visible = false;

        // --- MEDIAPIPE SETUP ---
        const createHandLandmarker = async () => {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 2
                });
                document.getElementById("loading").style.display = "none";
                startWebcam();
            } catch (error) {
                console.error("Error:", error);
                document.getElementById("loading").innerHTML = "‚ùå CAMERA ERROR - REFRESH PAGE";
            }
        };

        const startWebcam = () => {
            const video = document.getElementById("webcam");
            
            // Request kamera dengan kualitas terbaik
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    frameRate: { ideal: 30 },
                    facingMode: "user"
                } 
            }).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    webcamRunning = true;
                    predictWebcam();
                    
                    // Update status
                    document.getElementById("cam-quality").innerHTML = 
                        '<span class="green-dot"></span> CAMERA: ' + 
                        video.videoWidth + 'x' + video.videoHeight + ' ¬∑ 30fps';
                });
            }).catch(err => {
                console.error("Webcam error:", err);
                document.getElementById("loading").innerHTML = "‚ùå CANNOT ACCESS CAMERA";
                document.getElementById("loading").style.color = "#ff3333";
            });
        };

        // Fungsi global untuk toggle kamera
        window.toggleCamera = () => {
            cameraEnabled = !cameraEnabled;
            const video = document.getElementById("webcam");
            video.style.opacity = cameraEnabled ? "0.9" : "0.2";
            document.getElementById("cam-quality").innerHTML = cameraEnabled ? 
                '<span class="green-dot"></span> CAMERA ACTIVE ¬∑ READY' :
                '<span style="color:#ff3333">‚óè</span> CAMERA HIDDEN';
        };

        // --- MAIN LOOP ---
        async function predictWebcam() {
            const video = document.getElementById("webcam");
            if (!webcamRunning || !video) return;
            
            let startTimeMs = performance.now();
            
            if (lastVideoTime !== video.currentTime && handLandmarker) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, startTimeMs);

                // Update status
                if (results.landmarks.length === 2) {
                    document.getElementById("status").innerHTML = '<span>‚óâ</span> READY ¬∑ MERGE FINGERS';
                }

                if (results.landmarks.length === 2 && !isExploding) {
                    const handA = results.landmarks[0][8];
                    const handB = results.landmarks[1][8];
                    
                    const aspect = window.innerWidth / window.innerHeight;
                    const fovFactor = Math.tan((camera.fov / 2) * (Math.PI / 180)) * 2;
                    
                    const posA = new THREE.Vector3(
                        (handA.x - 0.5) * -1 * aspect * fovFactor * 2.2,
                        (handA.y - 0.5) * -1 * fovFactor * 2.2,
                        0
                    );
                    
                    const posB = new THREE.Vector3(
                        (handB.x - 0.5) * -1 * aspect * fovFactor * 2.2,
                        (handB.y - 0.5) * -1 * fovFactor * 2.2,
                        0
                    );

                    const dist = posA.distanceTo(posB);

                    // Update spheres
                    if (!redSphere.visible) {
                        redSphere.position.copy(posA);
                        blueSphere.position.copy(posB);
                        redSphere.visible = true;
                        blueSphere.visible = true;
                    } else {
                        redSphere.position.lerp(posA, 0.4);
                        blueSphere.position.lerp(posB, 0.4);
                    }
                    
                    // Rotate
                    redSphere.rotation.y += 0.03;
                    blueSphere.rotation.y -= 0.03;

                    // Trigger Hollow Purple
                    if (dist < CONFIG.mergeDistance) {
                        triggerHollowPurple(posA.clone().add(posB).multiplyScalar(0.5));
                    }
                } else if (results.landmarks.length < 2 && !isExploding) {
                    redSphere.visible = false;
                    blueSphere.visible = false;
                }
            }

            // Animate explosion
            if (isExploding) {
                animateExplosion();
            }

            // Rotate stars
            stars.rotation.y += 0.001;

            // Animate domain ring
            if (domainActive) {
                domainRing.rotation.z += 0.02;
                domainRing.rotation.x += 0.01;
                domainRing.scale.setScalar(1 + Math.sin(Date.now() * 0.008) * 0.1);
            }

            // Render
            composer.render();
            
            window.requestAnimationFrame(predictWebcam);
        }

        function triggerHollowPurple(position) {
            isExploding = true;
            domainActive = true;
            
            redSphere.visible = false;
            blueSphere.visible = false;
            domainRing.visible = true;
            
            purpleExplosion.position.copy(position);
            purpleExplosion.userData.active = true;
            purpleExplosion.userData.time = 0;
            
            // Reset particles
            const positions = purpleExplosion.geometry.attributes.position.array;
            for(let i = 0; i < positions.length; i++) {
                positions[i] = 0;
            }
            purpleExplosion.geometry.attributes.position.needsUpdate = true;
            
            // Visual feedback
            document.getElementById("status").innerHTML = '<span>‚ö°</span> HOLLOW PURPLE ¬∑ IMAGINARY TECHNIQUE';
        }

        function animateExplosion() {
            const positions = purpleExplosion.geometry.attributes.position.array;
            const velocities = purpleExplosion.userData.velocities;
            
            purpleExplosion.userData.time += 0.016;
            const time = purpleExplosion.userData.time;
            
            for (let i = 0; i < positions.length; i += 3) {
                positions[i] += velocities[i] * (1 + time * 0.3);
                positions[i+1] += velocities[i+1] * (1 + time * 0.3);
                positions[i+2] += velocities[i+2] * (1 + time * 0.3);
            }
            
            purpleExplosion.geometry.attributes.position.needsUpdate = true;
            purpleExplosion.material.opacity = Math.max(0, 1 - time * 0.7);
            domainRing.material.opacity = Math.max(0, 0.2 - time * 0.1);

            if (time > 2.0) {
                isExploding = false;
                domainActive = false;
                domainRing.visible = false;
                purpleExplosion.material.opacity = 1;
                purpleExplosion.userData.active = false;
                document.getElementById("status").innerHTML = '<span>‚óâ</span> BRING TWO INDEX FINGERS TOGETHER';
            }
        }

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        createHandLandmarker();
    </script>
</body>
</html>
