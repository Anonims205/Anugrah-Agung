<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GOJO SATORU - HOLLOW PURPLE: IMAGINARY TECHNIQUE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&family=Roboto+Mono:wght@300&display=swap');
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000;
        }
        
        video { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
            transform: scaleX(-1); 
            opacity: 0.4; 
            z-index: 0; 
            filter: grayscale(30%) contrast(120%);
        }
        
        canvas { 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
            transform: scaleX(-1); 
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            z-index: 10;
            text-shadow: 0 0 20px #A020F0, 0 0 40px #0000FF;
            animation: pulse 2s infinite;
        }
        
        #status {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: rgba(255,255,255,0.8);
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 12px 20px;
            border-radius: 30px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(160, 32, 240, 0.3);
            letter-spacing: 2px;
            pointer-events: none;
        }
        
        #status span {
            color: #A020F0;
            font-weight: bold;
            text-shadow: 0 0 10px #A020F0;
        }
        
        .glow-text {
            position: absolute;
            top: 30px;
            right: 30px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            z-index: 10;
            text-align: right;
            background: linear-gradient(90deg, transparent, rgba(0,0,0,0.7));
            padding: 20px 30px;
            border-radius: 0 0 0 20px;
            border-left: 3px solid #A020F0;
            pointer-events: none;
        }
        
        .glow-text h1 {
            margin: 0;
            font-size: 32px;
            color: #fff;
            text-shadow: 0 0 15px #A020F0;
            letter-spacing: 4px;
        }
        
        .glow-text p {
            margin: 5px 0 0;
            opacity: 0.7;
            font-size: 12px;
        }
        
        @keyframes pulse {
            0% { opacity: 1; text-shadow: 0 0 20px #A020F0, 0 0 40px #0000FF; }
            50% { opacity: 0.7; text-shadow: 0 0 40px #FF0000, 0 0 80px #A020F0; }
            100% { opacity: 1; text-shadow: 0 0 20px #A020F0, 0 0 40px #0000FF; }
        }
    </style>
</head>
<body>

    <div id="loading">⚡ AWAKENING CURSED ENERGY ⚡</div>
    
    <div class="glow-text">
        <h1>HOLLOW PURPLE</h1>
        <p>∞ IMAGINARY TECHNIQUE: VOID ∞</p>
    </div>
    
    <div id="status">
        <span>◉</span> MERGE TWO FINGERS TO ACTIVATE
    </div>
    
    <video id="webcam" playsinline autoplay muted></video>
    <canvas id="output_canvas"></canvas>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0';

        // --- KONFIGURASI ---
        const CONFIG = {
            redColor: 0xFF3333,
            blueColor: 0x3366FF,
            purpleColor: 0xAA44FF,
            mergeDistance: 0.2,
            particleCount: 2000,
            explosionParticles: 5000
        };

        // --- STATE ---
        let handLandmarker = null;
        let webcamRunning = false;
        let lastVideoTime = -1;
        let redSphere, blueSphere, purpleExplosion, domainExpansion;
        let isExploding = false;
        let domainActive = false;
        let particles = [];
        
        // Setup Scene dengan Post Processing
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.02);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 2.5;
        
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('output_canvas'), 
            alpha: false, 
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.2;

        // Post Processing untuk Glow Effect
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.5;
        bloomPass.radius = 0.5;
        
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- TEXTURE GENERATOR ---
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Core bright center
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.9)');
            gradient.addColorStop(0.4, 'rgba(200,200,255,0.5)');
            gradient.addColorStop(0.6, 'rgba(160,32,240,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            // Add star-like spikes
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI / 2);
                ctx.beginPath();
                ctx.moveTo(32, 32);
                ctx.lineTo(32 + Math.cos(angle) * 40, 32 + Math.sin(angle) * 40);
                ctx.stroke();
            }
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        const particleTexture = createParticleTexture();

        // --- BACKGROUND STARS ---
        function createBackgroundStars() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            for (let i = 0; i < 2000; i++) {
                const r = 5 + Math.random() * 10;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0x88AAFF,
                size: 0.03,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            
            return new THREE.Points(geometry, material);
        }

        const stars = createBackgroundStars();
        scene.add(stars);

        // --- ENERGY SPHERE (Advanced) ---
        function createEnergySphere(color, isRed = true) {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const sizes = [];
            const radius = 0.25;
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                // Distribusi spherical dengan kepadatan radial
                const r = radius * Math.pow(Math.random(), 1.5);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                // Tambahkan efek spiral untuk yang biru
                if (!isRed) {
                    const spiralFactor = 5;
                    const offset = r * 0.2 * Math.sin(theta * spiralFactor);
                    positions.push(
                        r * Math.sin(phi) * Math.cos(theta) + offset,
                        r * Math.sin(phi) * Math.sin(theta) + offset * 0.5,
                        r * Math.cos(phi) + offset * 0.3
                    );
                } else {
                    positions.push(
                        r * Math.sin(phi) * Math.cos(theta),
                        r * Math.sin(phi) * Math.sin(theta),
                        r * Math.cos(phi)
                    );
                }
                
                sizes.push(0.02 + Math.random() * 0.04);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(color) },
                    texture: { value: particleTexture },
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    varying float vSize;
                    void main() {
                        vSize = size;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform sampler2D texture;
                    varying float vSize;
                    
                    void main() {
                        vec4 texColor = texture2D(texture, gl_PointCoord);
                        vec3 finalColor = color + vec3(0.3, 0.1, 0.5); // Tambahan purple tint
                        gl_FragColor = vec4(finalColor, texColor.a * 0.8);
                        gl_FragColor = gl_FragColor * (0.8 + 0.4 * sin(gl_PointCoord.x * 20.0));
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const sphere = new THREE.Points(geometry, material);
            sphere.visible = false;
            return sphere;
        }

        // --- HOLLOW PURPLE EXPLOSION (Advanced) ---
        function createHollowPurple() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            const colors = [];
            const sizes = [];
            
            for (let i = 0; i < CONFIG.explosionParticles; i++) {
                positions.push(0, 0, 0);
                
                // Distribusi spherical dengan bias ke arah tertentu
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const speed = 0.03 + Math.random() * 0.15;
                
                velocities.push(
                    speed * Math.sin(phi) * Math.cos(theta),
                    speed * Math.sin(phi) * Math.sin(theta),
                    speed * Math.cos(phi)
                );
                
                // Warna gradien dari merah ke biru ke ungu
                const mix = Math.random();
                let r, g, b;
                if (mix < 0.33) {
                    r = 1.0; g = 0.2; b = 0.2; // Red
                } else if (mix < 0.66) {
                    r = 0.3; g = 0.5; b = 1.0; // Blue
                } else {
                    r = 0.8; g = 0.3; b = 1.0; // Purple
                }
                
                colors.push(r, g, b);
                sizes.push(0.02 + Math.random() * 0.06);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    texture: { value: particleTexture },
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    varying float vSize;
                    
                    void main() {
                        vColor = color;
                        vSize = size;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D texture;
                    varying vec3 vColor;
                    
                    void main() {
                        vec4 texColor = texture2D(texture, gl_PointCoord);
                        gl_FragColor = vec4(vColor, texColor.a);
                        gl_FragColor.rgb += vec3(0.3, 0.1, 0.5) * texColor.a; // Purple tint
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const system = new THREE.Points(geometry, material);
            system.userData = { 
                active: false, 
                time: 0,
                velocities: velocities
            };
            return system;
        }

        // --- DOMAIN EXPANSION EFFECT ---
        function createDomainEffect() {
            const geometry = new THREE.RingGeometry(0.8, 1.0, 64);
            const material = new THREE.MeshBasicMaterial({
                color: 0xAA44FF,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.15,
                blending: THREE.AdditiveBlending
            });
            const ring = new THREE.Mesh(geometry, material);
            ring.rotation.x = Math.PI / 2;
            ring.position.z = -0.5;
            return ring;
        }

        // Initialize objects
        redSphere = createEnergySphere(CONFIG.redColor, true);
        blueSphere = createEnergySphere(CONFIG.blueColor, false);
        purpleExplosion = createHollowPurple();
        domainExpansion = createDomainEffect();
        
        scene.add(redSphere);
        scene.add(blueSphere);
        scene.add(purpleExplosion);
        scene.add(domainExpansion);
        domainExpansion.visible = false;

        // --- MEDIAPIPE SETUP ---
        const createHandLandmarker = async () => {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 2,
                    minHandDetectionConfidence: 0.5,
                    minHandPresenceConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                document.getElementById("loading").style.display = "none";
                startWebcam();
            } catch (error) {
                console.error("Error initializing:", error);
            }
        };

        const startWebcam = () => {
            const video = document.getElementById("webcam");
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    facingMode: "user"
                } 
            }).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    webcamRunning = true;
                    predictWebcam();
                });
            }).catch(err => {
                console.error("Webcam error:", err);
            });
        };

        // --- MAIN LOOP ---
        async function predictWebcam() {
            const video = document.getElementById("webcam");
            if (!webcamRunning || !video) return;
            
            let startTimeMs = performance.now();
            
            if (lastVideoTime !== video.currentTime && handLandmarker) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, startTimeMs);

                // Update status display
                if (results.landmarks.length === 2) {
                    document.getElementById("status").innerHTML = '<span>◉</span> RED + BLUE = HOLLOW PURPLE';
                } else {
                    document.getElementById("status").innerHTML = '<span>◉</span> MERGE TWO FINGERS TO ACTIVATE';
                }

                if (results.landmarks.length === 2 && !isExploding) {
                    const handA = results.landmarks[0][8];
                    const handB = results.landmarks[1][8];
                    
                    const aspect = window.innerWidth / window.innerHeight;
                    const fovFactor = Math.tan((camera.fov / 2) * (Math.PI / 180)) * 2;
                    
                    const posA = new THREE.Vector3(
                        (handA.x - 0.5) * -1 * aspect * fovFactor * 2.2,
                        (handA.y - 0.5) * -1 * fovFactor * 2.2,
                        0
                    );
                    
                    const posB = new THREE.Vector3(
                        (handB.x - 0.5) * -1 * aspect * fovFactor * 2.2,
                        (handB.y - 0.5) * -1 * fovFactor * 2.2,
                        0
                    );

                    const dist = posA.distanceTo(posB);

                    // Update sphere positions with smooth interpolation
                    if (!redSphere.visible) {
                        redSphere.position.copy(posA);
                        blueSphere.position.copy(posB);
                        redSphere.visible = true;
                        blueSphere.visible = true;
                    } else {
                        redSphere.position.lerp(posA, 0.3);
                        blueSphere.position.lerp(posB, 0.3);
                    }
                    
                    // Rotate spheres
                    redSphere.rotation.y += 0.02;
                    redSphere.rotation.x += 0.01;
                    blueSphere.rotation.y -= 0.02;
                    blueSphere.rotation.z += 0.01;

                    // Update shader time
                    if (redSphere.material.uniforms) {
                        redSphere.material.uniforms.time.value += 0.01;
                        blueSphere.material.uniforms.time.value += 0.01;
                    }

                    // Trigger Hollow Purple
                    if (dist < CONFIG.mergeDistance) {
                        triggerHollowPurple(posA.clone().add(posB).multiplyScalar(0.5));
                    }
                } else if (results.landmarks.length < 2 && !isExploding) {
                    redSphere.visible = false;
                    blueSphere.visible = false;
                }
            }

            // Animate explosion
            if (isExploding) {
                animateExplosion();
            }

            // Rotate stars
            stars.rotation.y += 0.0005;
            stars.rotation.x += 0.0003;

            // Animate domain expansion if active
            if (domainActive) {
                domainExpansion.rotation.z += 0.01;
                domainExpansion.scale.setScalar(1 + Math.sin(Date.now() * 0.005) * 0.1);
            }

            // Render with bloom
            composer.render();
            
            window.requestAnimationFrame(predictWebcam);
        }

        function triggerHollowPurple(position) {
            isExploding = true;
            domainActive = true;
            
            redSphere.visible = false;
            blueSphere.visible = false;
            domainExpansion.visible = true;
            
            purpleExplosion.position.copy(position);
            purpleExplosion.userData.active = true;
            purpleExplosion.userData.time = 0;
            
            // Reset particles
            const positions = purpleExplosion.geometry.attributes.position.array;
            for(let i = 0; i < positions.length; i++) {
                positions[i] = 0;
            }
            purpleExplosion.geometry.attributes.position.needsUpdate = true;
            
            // Camera shake effect
            camera.position.z = 2.2;
            setTimeout(() => {
                camera.position.z = 2.5;
            }, 200);
        }

        function animateExplosion() {
            const positions = purpleExplosion.geometry.attributes.position.array;
            const velocities = purpleExplosion.userData.velocities;
            
            purpleExplosion.userData.time += 0.016;
            const time = purpleExplosion.userData.time;
            
            for (let i = 0; i < positions.length; i += 3) {
                // Gerakan utama
                positions[i] += velocities[i] * (1 + time * 0.5);
                positions[i+1] += velocities[i+1] * (1 + time * 0.5);
                positions[i+2] += velocities[i+2] * (1 + time * 0.5);
                
                // Tambahan efek vortex
                const dist = Math.sqrt(
                    positions[i]*positions[i] + 
                    positions[i+1]*positions[i+1] + 
                    positions[i+2]*positions[i+2]
                );
                
                if (dist < 1.0) {
                    positions[i] += (Math.random() - 0.5) * 0.03;
                    positions[i+1] += (Math.random() - 0.5) * 0.03;
                }
            }
            
            purpleExplosion.geometry.attributes.position.needsUpdate = true;
            
            // Opacity fade
            purpleExplosion.material.opacity = Math.max(0, 1 - time * 0.8);
            
            // Domain expansion fade
            domainExpansion.material.opacity = Math.max(0, 0.15 - time * 0.1);

            if (time > 2.5) {
                isExploding = false;
                domainActive = false;
                domainExpansion.visible = false;
                purpleExplosion.material.opacity = 1;
                purpleExplosion.userData.active = false;
            }
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start everything
        createHandLandmarker();
    </script>
</body>
</html>
