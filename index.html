<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gojo Satoru's Hollow Purple - Genius Hand Tracking</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            background: #0a0a0a; /* Darker background */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; /* Prevent scrollbar from particle effects */
        }
        .container {
            position: relative;
            box-shadow: 0 0 50px rgba(173, 216, 230, 0.4); /* Light blue glow */
            border-radius: 20px;
            overflow: hidden;
            border: 2px solid #555;
        }
        #input_video {
            display: none;
        }
        #output_canvas {
            transform: scaleX(-1); /* Mirror effect */
            background: black; /* Solid black background for effects */
            display: block; /* Ensure it takes up space */
        }
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 18px;
            border-radius: 10px;
            pointer-events: none;
            z-index: 10;
            font-size: 1.1em;
            color: #00FF7F; /* Neon green */
        }
        .status-text {
            color: white;
            font-weight: bold;
        }
        .gojo-message {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            font-size: 1.5em;
            color: #ADD8E6; /* Light blue */
            text-shadow: 0 0 15px #ADD8E6, 0 0 25px #ADD8E6;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
            z-index: 10;
        }
        .gojo-message.active {
            opacity: 1;
        }
    </style>
</head>
<body>

<div class="container">
    <div class="info">Status: <span id="status" class="status-text">Memuat Model...</span></div>
    <video id="input_video"></video>
    <canvas id="output_canvas" width="1280" height="720"></canvas>
    <div id="gojoMessage" class="gojo-message">Hollow Purple!</div>
</div>

<script type="module">
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const statusText = document.getElementById('status');
    const gojoMessage = document.getElementById('gojoMessage');

    // Particle system for the energy effects
    let particles = [];
    const MAX_PARTICLES = 100;

    class Particle {
        constructor(x, y, color, size, vx = 0, vy = 0) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.size = size;
            this.vx = vx + (Math.random() - 0.5) * 2; // Random initial velocity
            this.vy = vy + (Math.random() - 0.5) * 2;
            this.alpha = 1;
            this.gravity = 0.05; // Light gravity for upward/outward motion
            this.drag = 0.98; // Slow down particles
        }

        update() {
            this.vx *= this.drag;
            this.vy *= this.drag;
            this.vy += this.gravity; // Gravity effect
            this.x += this.vx;
            this.y += this.vy;
            this.alpha -= 0.01; // Fade out
            this.size *= 0.98; // Shrink
        }

        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.shadowBlur = this.size * 2;
            ctx.shadowColor = this.color;
            ctx.fill();
            ctx.restore();
        }
    }

    function createParticles(x, y, color, count, initialVelX = 0, initialVelY = 0) {
        for (let i = 0; i < count; i++) {
            if (particles.length < MAX_PARTICLES) {
                const size = Math.random() * 5 + 2;
                particles.push(new Particle(x, y, color, size, initialVelX, initialVelY));
            }
        }
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if (particles[i].alpha <= 0.05 || particles[i].size <= 0.5) {
                particles.splice(i, 1); // Remove faded/shrunk particles
            }
        }
    }

    // Hand tracking variables
    let leftIndexTip = null;
    let rightIndexTip = null;
    let combinedEnergyActive = false;
    let lastCombinedTime = 0;
    const COMBINE_DISTANCE_THRESHOLD = 80; // pixels
    const OPEN_PALM_THRESHOLD = 0.6; // Ratio of open fingers to closed fingers
    const FINGER_TIP_IDS = [mpHands.HandLandmark.INDEX_FINGER_TIP, 
                            mpHands.HandLandmark.MIDDLE_FINGER_TIP, 
                            mpHands.HandLandmark.RING_FINGER_TIP, 
                            mpHands.HandLandmark.PINKY_TIP];
    
    // Function to check if a hand is "open"
    // This is a simplified check. More robust would involve distances between tips and MCPs
    function isOpenHand(landmarks) {
        // Check if the tips of index, middle, ring, pinky fingers are above their respective MCPs
        // (assuming y-axis for "above" with inverted canvas coordinates)
        let openCount = 0;
        if (landmarks[mpHands.HandLandmark.INDEX_FINGER_TIP].y < landmarks[mpHands.HandLandmark.INDEX_FINGER_MCP].y) openCount++;
        if (landmarks[mpHands.HandLandmark.MIDDLE_FINGER_TIP].y < landmarks[mpHands.HandLandmark.MIDDLE_FINGER_MCP].y) openCount++;
        if (landmarks[mpHands.HandLandmark.RING_FINGER_TIP].y < landmarks[mpHands.HandLandmark.RING_FINGER_MCP].y) openCount++;
        if (landmarks[mpHands.HandLandmark.PINKY_FINGER_TIP].y < landmarks[mpHands.HandLandmark.PINKY_FINGER_MCP].y) openCount++;
        
        // Check thumb tip relative to base
        if (landmarks[mpHands.HandLandmark.THUMB_TIP].x > landmarks[mpHands.HandLandmark.THUMB_CMC].x && // Right hand
            landmarks[mpHands.HandLandmark.THUMB_TIP].y < landmarks[mpHands.HandLandmark.THUMB_CMC].y) {
            openCount++;
        } else if (landmarks[mpHands.HandLandmark.THUMB_TIP].x < landmarks[mpHands.HandLandmark.THUMB_CMC].x && // Left hand
                   landmarks[mpHands.HandLandmark.THUMB_TIP].y < landmarks[mpHands.HandLandmark.THUMB_CMC].y) {
            openCount++;
        }

        return openCount >= 4; // At least 4 fingers "open"
    }


    function onResults(results) {
        statusText.innerText = "Aktif";
        
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        // Draw the camera feed, mirrored
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        leftIndexTip = null;
        rightIndexTip = null;
        let isLeftHandOpen = false;
        let isRightHandOpen = false;

        if (results.multiHandLandmarks) {
            for (const i in results.multiHandLandmarks) {
                const landmarks = results.multiHandLandmarks[i];
                const handedness = results.multiHandedness[i].classification[0].label; // 'Left' or 'Right'

                // Convert normalized coordinates to pixel coordinates
                const indexTip = {
                    x: landmarks[mpHands.HandLandmark.INDEX_FINGER_TIP].x * canvasElement.width,
                    y: landmarks[mpHands.HandLandmark.INDEX_FINGER_TIP].y * canvasElement.height
                };

                // Store index finger tip positions
                if (handedness === 'Left') {
                    leftIndexTip = indexTip;
                    isLeftHandOpen = isOpenHand(landmarks);
                    // Draw Red Energy on Left Index Finger
                    createParticles(indexTip.x, indexTip.y, 'rgba(255, 0, 0, 0.7)', 2);
                    // Also draw the landmark
                    drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 2, radius: 5});
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#FFCCCC', lineWidth: 3});

                } else if (handedness === 'Right') {
                    rightIndexTip = indexTip;
                    isRightHandOpen = isOpenHand(landmarks);
                    // Draw Blue Energy on Right Index Finger
                    createParticles(indexTip.x, indexTip.y, 'rgba(0, 0, 255, 0.7)', 2);
                    // Also draw the landmark
                    drawLandmarks(canvasCtx, landmarks, {color: '#0000FF', lineWidth: 2, radius: 5});
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#CCCCFF', lineWidth: 3});
                }
            }
        }

        // Hollow Purple Logic
        if (leftIndexTip && rightIndexTip) {
            const distance = Math.sqrt(
                Math.pow(leftIndexTip.x - rightIndexTip.x, 2) +
                Math.pow(leftIndexTip.y - rightIndexTip.y, 2)
            );

            if (distance < COMBINE_DISTANCE_THRESHOLD) {
                // Fingers are close enough, combine energy
                combinedEnergyActive = true;
                const midX = (leftIndexTip.x + rightIndexTip.x) / 2;
                const midY = (leftIndexTip.y + rightIndexTip.y) / 2;
                createParticles(midX, midY, 'rgba(128, 0, 128, 0.9)', 5); // Purple
                lastCombinedTime = Date.now();
                gojoMessage.classList.remove('active'); // Hide message while combining

            } else {
                // If combined energy was active and fingers separate, check for release
                if (combinedEnergyActive && (isLeftHandOpen || isRightHandOpen) && (Date.now() - lastCombinedTime < 2000)) { // Small window for release after combination
                    // Release Hollow Purple!
                    const midX = (leftIndexTip.x + rightIndexTip.x) / 2;
                    const midY = (leftIndexTip.y + rightIndexTip.y) / 2;
                    
                    // Simulate explosion of purple energy forward (towards the camera, so outwards on canvas)
                    for (let i = 0; i < 50; i++) {
                        // Stronger initial velocity for the "burst"
                        const angle = Math.random() * Math.PI * 2; // Random direction
                        const speed = Math.random() * 15 + 10;
                        createParticles(midX, midY, 'rgba(128, 0, 128, 0.9)', 1, Math.cos(angle) * speed, Math.sin(angle) * speed);
                    }
                    gojoMessage.classList.add('active');
                    setTimeout(() => gojoMessage.classList.remove('active'), 1500); // Hide message after 1.5s
                }
                combinedEnergyActive = false;
            }
        } else {
            combinedEnergyActive = false; // Reset if only one hand or no hands
            gojoMessage.classList.remove('active');
        }

        // Update and draw particles
        updateParticles();
        for (const p of particles) {
            p.draw(canvasCtx);
        }

        canvasCtx.restore();
        requestAnimationFrame(() => {}); // This helps keep animation smooth
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1, // Higher complexity for better accuracy (0 or 1)
        minDetectionConfidence: 0.7, // Higher confidence to reduce false positives
        minTrackingConfidence: 0.6
    });

    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 1280,
        height: 720
    });
    camera.start();
</script>

</body>
</html>
