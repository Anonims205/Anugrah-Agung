<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gojo Hand Tracking - Red, Blue, Purple</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        .container { position: relative; width: 100vw; height: 100vh; }
        #webcam { position: absolute; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #three-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; pointer-events: none; }
        #instructions {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            color: white; background: rgba(0,0,0,0.6); padding: 15px 25px;
            border-radius: 30px; border: 1px solid #7d2ae8; z-index: 10; text-align: center;
        }
        .technique-label { font-weight: bold; text-transform: uppercase; letter-spacing: 2px; }
    </style>
</head>
<body>
    <div class="container">
        <video id="webcam" autoplay playsinline></video>
        <div id="three-canvas"></div>
        <div id="instructions">
            <div id="status">Initializing Six Eyes...</div>
            <div style="font-size: 12px; margin-top: 5px; opacity: 0.8;">
                Right Index: <span style="color: #ff4d4d">RED</span> | Left Index: <span style="color: #4d94ff">BLUE</span> | Together: <span style="color: #a366ff">PURPLE</span>
            </div>
        </div>
    </div>

    <!-- Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/three.min.js"></script>
    
    <!-- Post Processing for the Cinematic Glow (Bloom) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/shaders/LuminosityHighPassShader.js"></script>

    <script>
        const videoElement = document.getElementById('webcam');
        const statusElement = document.getElementById('status');
        let scene, camera, renderer, composer, clock;
        let redSphere, blueSphere, purpleSphere, particles;
        let handData = { left: null, right: null };
        
        // --- CONFIGURATION ---
        const PARAMS = {
            bloomStrength: 2.5,
            bloomRadius: 0.5,
            bloomThreshold: 0.1,
            particleCount: 500,
            mergeDistance: 0.15 // Normalized distance to trigger Purple
        };

        async function init() {
            setupThreeJS();
            setupParticles();
            createTechniqueSpheres();
            await setupMediaPipe();
            animate();
        }

        function setupThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            clock = new THREE.Clock();

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('three-canvas').appendChild(renderer.domElement);

            // Post-Processing (Bloom is the secret to the "Anime Energy" look)
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                PARAMS.bloomStrength, PARAMS.bloomRadius, PARAMS.bloomThreshold
            );
            
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createTechniqueSpheres() {
            const sphereGeo = new THREE.SphereGeometry(1, 32, 32);
            
            // Reversal Red (Plasma)
            const redMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8 });
            redSphere = new THREE.Mesh(sphereGeo, redMat);
            redSphere.scale.set(0.2, 0.2, 0.2);
            redSphere.visible = false;
            scene.add(redSphere);

            // Lapse Blue (Electric)
            const blueMat = new THREE.MeshBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0.8 });
            blueSphere = new THREE.Mesh(sphereGeo, blueMat);
            blueSphere.scale.set(0.2, 0.2, 0.2);
            blueSphere.visible = false;
            scene.add(blueSphere);

            // Hollow Purple (Gravity)
            const purpleGroup = new THREE.Group();
            const coreMat = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Black core
            const core = new THREE.Mesh(sphereGeo, coreMat);
            core.scale.set(0.3, 0.3, 0.3);
            
            const auraMat = new THREE.MeshBasicMaterial({ color: 0xaa00ff, transparent: true, opacity: 0.6, wireframe: true });
            const aura = new THREE.Mesh(sphereGeo, auraMat);
            aura.scale.set(0.5, 0.5, 0.5);
            
            purpleGroup.add(core, aura);
            purpleSphere = purpleGroup;
            purpleSphere.visible = false;
            scene.add(purpleSphere);
        }

        function setupParticles() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(PARAMS.particleCount * 3);
            const colors = new Float32Array(PARAMS.particleCount * 3);
            
            for(let i=0; i<PARAMS.particleCount * 3; i++) {
                pos[i] = (Math.random() - 0.5) * 10;
            }
            
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ size: 0.05, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
            particles = new THREE.Points(geo, mat);
            scene.add(particles);
        }

        async function setupMediaPipe() {
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onResults);

            const cameraPipe = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 1280, height: 720
            });
            cameraPipe.start();
            statusElement.textContent = "Six Eyes Active";
        }

        function onResults(results) {
            handData.left = null;
            handData.right = null;

            if (results.multiHandLandmarks) {
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const label = results.multiHandedness[index].label; // Left or Right
                    // Note: MediaPipe labels are mirrored by default
                    if (label === 'Left') handData.right = landmarks; 
                    else handData.left = landmarks;
                });
            }
        }

        function updateEnergyLogic() {
            const time = clock.getElapsedTime();
            
            // Hide all by default
            redSphere.visible = false;
            blueSphere.visible = false;
            purpleSphere.visible = false;

            if (handData.left && handData.right) {
                const lIndex = handData.left[8];
                const rIndex = handData.right[8];
                
                // Map to 3D space
                const lPos = new THREE.Vector3((lIndex.x - 0.5) * -10, (0.5 - lIndex.y) * 6, 0);
                const rPos = new THREE.Vector3((rIndex.x - 0.5) * -10, (0.5 - rIndex.y) * 6, 0);
                
                const dist = lPos.distanceTo(rPos);

                if (dist < 1.2) {
                    // PURPLE MODE
                    purpleSphere.visible = true;
                    purpleSphere.position.lerpVectors(lPos, rPos, 0.5);
                    purpleSphere.scale.setScalar(1 + Math.sin(time * 10) * 0.1);
                    purpleSphere.rotation.y += 0.2;
                    statusElement.textContent = "ðŸ«´ Hollow Technique: Purple";
                    statusElement.style.color = "#a366ff";
                    updateParticles(purpleSphere.position, 0xaa00ff);
                } else {
                    // SEPARATE MODE
                    showTechnique(redSphere, rPos, "Red", "#ff4d4d");
                    showTechnique(blueSphere, lPos, "Blue", "#4d94ff");
                    statusElement.textContent = "Amplification/Reversal";
                    statusElement.style.color = "white";
                }
            } else if (handData.right) {
                const rIndex = handData.right[8];
                const rPos = new THREE.Vector3((rIndex.x - 0.5) * -10, (0.5 - rIndex.y) * 6, 0);
                showTechnique(redSphere, rPos, "Red", "#ff4d4d");
                updateParticles(rPos, 0xff0000);
            } else if (handData.left) {
                const lIndex = handData.left[8];
                const lPos = new THREE.Vector3((lIndex.x - 0.5) * -10, (0.5 - lIndex.y) * 6, 0);
                showTechnique(blueSphere, lPos, "Blue", "#4d94ff");
                updateParticles(lPos, 0x0088ff);
            }
        }

        function showTechnique(obj, pos, name, color) {
            obj.visible = true;
            obj.position.copy(pos);
            obj.scale.setScalar(0.3 + Math.sin(Date.now() * 0.01) * 0.05);
        }

        function updateParticles(targetPos, colorHex) {
            const positions = particles.geometry.attributes.position.array;
            const colors = new THREE.Color(colorHex);
            const colorAttr = new THREE.Float32Array(PARAMS.particleCount * 3);

            for (let i = 0; i < PARAMS.particleCount; i++) {
                const i3 = i * 3;
                // Vortex physics: pull toward center and rotate
                const p = new THREE.Vector3(positions[i3], positions[i3+1], positions[i3+2]);
                p.sub(targetPos);
                p.applyAxisAngle(new THREE.Vector3(0,0,1), 0.1);
                p.multiplyScalar(0.95); // Gravity pull
                
                if (p.length() < 0.1) { // Respawn far away
                    const angle = Math.random() * Math.PI * 2;
                    p.set(Math.cos(angle) * 3, Math.sin(angle) * 3, (Math.random()-0.5)*2);
                }
                
                p.add(targetPos);
                positions[i3] = p.x;
                positions[i3+1] = p.y;
                positions[i3+2] = p.z;

                colorAttr[i3] = colors.r;
                colorAttr[i3+1] = colors.g;
                colorAttr[i3+2] = colors.b;
            }
            particles.geometry.setAttribute('color', new THREE.BufferAttribute(colorAttr, 3));
            particles.geometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            updateEnergyLogic();
            composer.render();
        }

        init();
    </script>
</body>
</html>
